WEBVTT
Kind: captions
Language: en-US

00:00:04.910 --> 00:00:08.609
So what I want to talk about next is a solution,

00:00:08.609 --> 00:00:10.635
uh, to- to these questions.

00:00:10.635 --> 00:00:11.880
And in- in particular,

00:00:11.880 --> 00:00:14.520
the method we'll talk about is called Query2box,

00:00:14.520 --> 00:00:20.175
that allows us to reason over knowledge graphs using what is called, uh, Box Embeddings.

00:00:20.175 --> 00:00:21.300
So let me first,, uh,

00:00:21.300 --> 00:00:24.855
motivate the setting, and then give you how this method works.

00:00:24.855 --> 00:00:30.995
So we said we wanna answer more complex predictive queries on, uh, graphs.

00:00:30.995 --> 00:00:34.565
And let's say that we wanna be able to also include conjunctions,

00:00:34.565 --> 00:00:37.850
so not just sets, but also intersections.

00:00:37.850 --> 00:00:42.500
We wanna be able to take an intersection of two sets in the embedding space.

00:00:42.500 --> 00:00:45.290
What we need to be able to do is two things.

00:00:45.290 --> 00:00:48.680
We need to be able to now figure out how are we going to

00:00:48.680 --> 00:00:53.605
represent a set of entities in the embedding space?

00:00:53.605 --> 00:00:58.775
And then, how are we going to define the intersection operator in the embedding space?

00:00:58.775 --> 00:01:00.720
How do we quickly take, uh,

00:01:00.720 --> 00:01:02.465
two sets of entities and say,

00:01:02.465 --> 00:01:06.365
what are the entities that are in the intersection, uh, between them?

00:01:06.365 --> 00:01:08.990
So let's see how to do that.

00:01:08.990 --> 00:01:11.445
The key inside that, uh,

00:01:11.445 --> 00:01:15.610
will allow us to do this is the concept of a box eEmbedding.

00:01:15.610 --> 00:01:20.450
What this means is that we're going to embed all the entities,

00:01:20.450 --> 00:01:25.700
and the relations in our space as boxes,

00:01:25.700 --> 00:01:30.030
as, uh, multidimen- dimensional, uh, rectangles.

00:01:30.030 --> 00:01:32.640
And the intuition would be that every box is

00:01:32.640 --> 00:01:36.225
defined by two points where it's defined by the center,

00:01:36.225 --> 00:01:38.010
and is defined by the corner.

00:01:38.010 --> 00:01:39.100
We'll call the center,

00:01:39.100 --> 00:01:41.650
center, and we'll call the corner, offset.

00:01:41.650 --> 00:01:43.180
So this basically tells me, you know,

00:01:43.180 --> 00:01:45.670
what is the offset in, uh, one dimension?

00:01:45.670 --> 00:01:47.360
What is the offset in the other dimension?

00:01:47.360 --> 00:01:49.965
This basically tells me what is the size of the box.

00:01:49.965 --> 00:01:52.645
And intuitively, we want to,

00:01:52.645 --> 00:01:55.525
uh, let say, in our case of Fulvestrant,

00:01:55.525 --> 00:02:02.385
we wanna embed all of its side effects in a- in a box, uh, that is,

00:02:02.385 --> 00:02:04.380
uh- so that in basically, uh,

00:02:04.380 --> 00:02:08.675
all the side effects caused by Fulvestrant will be- will be embedded close together,

00:02:08.675 --> 00:02:10.880
and they will be enclosed in this,

00:02:10.880 --> 00:02:12.515
uh, in this box.

00:02:12.515 --> 00:02:14.495
So that's the- that's the idea.

00:02:14.495 --> 00:02:16.100
So let me now tell you,

00:02:16.100 --> 00:02:18.140
uh, keep kind of building on this.

00:02:18.140 --> 00:02:21.380
So, um, the reason why we wanna embed things as

00:02:21.380 --> 00:02:25.580
boxes is because intersection of boxes is well-defined.

00:02:25.580 --> 00:02:27.530
Right? Basically, what I mean by that is,

00:02:27.530 --> 00:02:29.165
uh, if you take two boxes,

00:02:29.165 --> 00:02:30.560
and take an intersection,

00:02:30.560 --> 00:02:32.710
intersection of two boxes is a box.

00:02:32.710 --> 00:02:34.700
It can be an empty box,

00:02:34.700 --> 00:02:37.070
right, a box of size 0.

00:02:37.070 --> 00:02:39.845
But if there is any non-trivial overlap,

00:02:39.845 --> 00:02:41.420
that overlap will be a box.

00:02:41.420 --> 00:02:45.575
So it means we can now think about how are we going to define

00:02:45.575 --> 00:02:48.979
trans-geometric transformations over these boxes

00:02:48.979 --> 00:02:52.360
that corresponds to logical, uh, operators.

00:02:52.360 --> 00:02:55.790
Right? So when we traverse the knowledge graph to find answers,

00:02:55.790 --> 00:02:58.145
each step will basically, uh,

00:02:58.145 --> 00:03:00.485
produce a set of reachable entities,

00:03:00.485 --> 00:03:04.285
a set of entities that the query covers, uh, so far.

00:03:04.285 --> 00:03:08.180
Um, and we are going to now model this set of

00:03:08.180 --> 00:03:12.080
entities with a box that encloses all of them. All right.

00:03:12.080 --> 00:03:15.000
So, um, this means that we can,

00:03:15.000 --> 00:03:20.160
uh- that box provide a powerful obstruction because boxes kind of enclose,

00:03:20.160 --> 00:03:22.530
uh, sets of, uh, entities.

00:03:22.530 --> 00:03:26.180
And then we can define geometric intersection operator,

00:03:26.180 --> 00:03:27.785
uh, over, uh, let's say,

00:03:27.785 --> 00:03:29.540
two, or multiple boxes,

00:03:29.540 --> 00:03:31.285
and when- when we intersect them,

00:03:31.285 --> 00:03:33.195
the intersection is still a box.

00:03:33.195 --> 00:03:36.945
So we- it's very easy again to have this compositional property,

00:03:36.945 --> 00:03:38.250
where we can take boxes,

00:03:38.250 --> 00:03:40.300
intersect them in arbitrary ways,

00:03:40.300 --> 00:03:44.115
but, uh, we always are left of- are left out with a box,

00:03:44.115 --> 00:03:46.250
which we can further kind of manipulate,

00:03:46.250 --> 00:03:48.295
and change in shape however we like.

00:03:48.295 --> 00:03:50.010
So that's why this is kind of cool,

00:03:50.010 --> 00:03:52.740
um, and, uh, exciting.

00:03:52.740 --> 00:03:58.275
So, uh, what does it mean to be a- to be able to embed with boxes?

00:03:58.275 --> 00:04:01.585
Here is what we need to figure out or here's what we need to learn.

00:04:01.585 --> 00:04:03.235
We need to learn uh,

00:04:03.235 --> 00:04:05.755
opa- uh, we need to learn entity embeddings.

00:04:05.755 --> 00:04:08.500
So every embedding, entity will have an embedding,

00:04:08.500 --> 00:04:09.640
and it will be a box,

00:04:09.640 --> 00:04:12.430
but it will be a- a- a trivial box.

00:04:12.430 --> 00:04:13.995
So basically, it will be a point, right?

00:04:13.995 --> 00:04:18.675
It will be a box of a- a size 0, or volume 0.

00:04:18.675 --> 00:04:20.705
Then we'll have relation embeddings,

00:04:20.705 --> 00:04:22.460
which will basically, um,

00:04:22.460 --> 00:04:24.460
generalize the notion of params,

00:04:24.460 --> 00:04:28.365
where we are going to take- now learn how to move around,

00:04:28.365 --> 00:04:31.155
and, er, expand, or shrink boxes.

00:04:31.155 --> 00:04:34.680
So the relation embeddings will be like vectors,

00:04:34.680 --> 00:04:36.945
that are going to take boxes,

00:04:36.945 --> 00:04:38.385
and move them around.

00:04:38.385 --> 00:04:42.360
Then intersection operator is something that is- that is new.

00:04:42.360 --> 00:04:44.480
Uh, the intersection operator will take, uh,

00:04:44.480 --> 00:04:46.315
multiple boxes on the input,

00:04:46.315 --> 00:04:48.300
and will output a single box.

00:04:48.300 --> 00:04:52.290
And intuitively, this will be an intersection of, uh, boxes.

00:04:52.290 --> 00:04:55.770
But we are going to learn this, uh, intersection operator.

00:04:55.770 --> 00:04:58.850
Um, so it'll have some parameters so that our,

00:04:58.850 --> 00:05:01.055
uh, approach will be even more,

00:05:01.055 --> 00:05:03.235
uh, expressive, and more robust.

00:05:03.235 --> 00:05:05.370
So how will this work?

00:05:05.370 --> 00:05:07.050
Let me just kind of give you a cartoon.

00:05:07.050 --> 00:05:09.480
Again, we are talking about, uh, you know,

00:05:09.480 --> 00:05:12.480
what are drugs that cause shortness of breath,

00:05:12.480 --> 00:05:16.680
and treat diseases associated with protein, uh, ESR2?

00:05:16.680 --> 00:05:18.140
Uh, the way we do this,

00:05:18.140 --> 00:05:19.730
right, in terms of query plan,

00:05:19.730 --> 00:05:22.840
we say a-ha, we start with a anchor entity, ESR2.

00:05:22.840 --> 00:05:24.915
We wanna move across the, um,

00:05:24.915 --> 00:05:28.605
across the relationship called associated, uh, with.

00:05:28.605 --> 00:05:31.550
And the way we are going to do this is that we are going to define

00:05:31.550 --> 00:05:34.970
this relation projection operator P. Uh,

00:05:34.970 --> 00:05:36.125
here is how it's defined.

00:05:36.125 --> 00:05:38.540
We'll have one for every relation.

00:05:38.540 --> 00:05:41.570
And essentially what this will do is it will take one box,

00:05:41.570 --> 00:05:45.004
and it will kind of move it according to our given relation,

00:05:45.004 --> 00:05:47.780
and also, um, expand its,

00:05:47.780 --> 00:05:49.160
uh, or shrink its size.

00:05:49.160 --> 00:05:52.440
So basically, we will have, um,

00:05:52.440 --> 00:05:57.450
this learned, uh, ve- this learned operator for every relation.

00:05:57.450 --> 00:05:59.265
It's going to move the center,

00:05:59.265 --> 00:06:01.590
and it's going to change the offset.

00:06:01.590 --> 00:06:05.180
So basically, it will change the size as well as the location,

00:06:05.180 --> 00:06:06.290
uh, of the box.

00:06:06.290 --> 00:06:08.835
So I can start with, uh, q,

00:06:08.835 --> 00:06:10.695
and then I apply this, uh,

00:06:10.695 --> 00:06:14.640
projection r to it to get a new box, uh, q prime.

00:06:14.640 --> 00:06:17.265
So that's the projection operator.

00:06:17.265 --> 00:06:21.240
So how would this look in our case if I started the ESR2,

00:06:21.240 --> 00:06:24.395
and I wanna move across the associated relation?

00:06:24.395 --> 00:06:27.790
I would take this trivial box, apply my, uh,

00:06:27.790 --> 00:06:29.200
r- r- r associated,

00:06:29.200 --> 00:06:31.200
and basically, this would move it, uh,

00:06:31.200 --> 00:06:33.135
and expand it to include, uh,

00:06:33.135 --> 00:06:38.505
all the- all the diseases associated with, uh, ESR2.

00:06:38.505 --> 00:06:41.925
Now, um- now that I have a new box,

00:06:41.925 --> 00:06:44.660
I can again, simply kind of follow the query plan.

00:06:44.660 --> 00:06:47.820
Now I wanna traverse over a TreatedBy,

00:06:47.820 --> 00:06:51.585
which again, I would take this box, apply TreatedBy, uh,

00:06:51.585 --> 00:06:55.060
projection operator, the transformation to the box, which would, you know,

00:06:55.060 --> 00:06:56.605
further move it, and you know,

00:06:56.605 --> 00:06:57.910
expand or shrink it,

00:06:57.910 --> 00:06:59.620
depends what the model we learn.

00:06:59.620 --> 00:07:05.765
Uh, and then the idea is that whatever the answers to this path to a predictive query,

00:07:05.765 --> 00:07:07.130
those are the entities, uh,

00:07:07.130 --> 00:07:09.280
inside, uh, the box.

00:07:09.280 --> 00:07:11.955
And that's essentially the idea, right?

00:07:11.955 --> 00:07:15.380
Now, I can also try to answer the second part of the query,

00:07:15.380 --> 00:07:18.410
which is shortness of breath CausedBy.

00:07:18.410 --> 00:07:20.450
So I start with the shortness of breath entity,

00:07:20.450 --> 00:07:24.790
apply this CausedBy box transformation to get another box.

00:07:24.790 --> 00:07:28.410
And now, uh, what are the entities that are,

00:07:28.410 --> 00:07:30.530
uh, in the intersection of the two boxes?

00:07:30.530 --> 00:07:33.980
Uh, those will be basically the answers to my query.

00:07:33.980 --> 00:07:36.840
In our, uh- in our case, uh,

00:07:36.840 --> 00:07:39.240
this would be these, uh- these two entities,

00:07:39.240 --> 00:07:41.505
uh, fulvestrant, uh, and the other drug.

00:07:41.505 --> 00:07:43.260
Right? So that's essentially the idea.

00:07:43.260 --> 00:07:46.010
I have one box, I have the other box I'm interested

00:07:46.010 --> 00:07:49.390
in, what is the intersection, uh, of them?

00:07:49.390 --> 00:07:55.520
So that's, um, the idea about how would I do the embedding grid boxes?

00:07:55.520 --> 00:08:01.400
Now, let me talk about how does- how is this intersection operator, uh, really defined?

00:08:01.400 --> 00:08:06.230
Uh, one approach would be to simply define it as kind of hardcore,

00:08:06.230 --> 00:08:08.900
or just mathematically as intersection of boxes,

00:08:08.900 --> 00:08:11.125
almost like as- as in a Venn diagram.

00:08:11.125 --> 00:08:14.880
Uh, we wanna be a bit more, um, flexible.

00:08:14.880 --> 00:08:17.400
And we wanna do, uh, uh,

00:08:17.400 --> 00:08:20.849
and learn a geometric intersection operator,

00:08:20.849 --> 00:08:22.050
we'll call it J.

00:08:22.050 --> 00:08:25.140
Where the idea is we wanna take multiple boxes as input,

00:08:25.140 --> 00:08:26.760
and produce the intersection,

00:08:26.760 --> 00:08:28.210
uh, of these boxes.

00:08:28.210 --> 00:08:30.100
We'll call it the intersection box.

00:08:30.100 --> 00:08:31.480
Uh, and the intuition,

00:08:31.480 --> 00:08:34.180
we are going to use this to say the center of

00:08:34.180 --> 00:08:38.400
the new box should be close to the centers of the input boxes.

00:08:38.400 --> 00:08:41.690
So these are the three input boxes and the centers.

00:08:41.690 --> 00:08:45.840
Um, so we would like to take kind of intuitively the intersection between them.

00:08:45.840 --> 00:08:50.080
So we want the new center to be kind of a function of these three centers,

00:08:50.080 --> 00:08:53.250
and we want the intersection to be kind of close to- to them.

00:08:53.250 --> 00:08:54.935
And then the offset,

00:08:54.935 --> 00:08:56.465
so the size of the box,

00:08:56.465 --> 00:08:58.360
should shrink, since, uh,

00:08:58.360 --> 00:09:02.150
the size of the intersection is smaller than the size of,

00:09:02.150 --> 00:09:04.220
uh, any of the input sets,

00:09:04.220 --> 00:09:05.795
or any of the input boxes.

00:09:05.795 --> 00:09:07.220
So formally, we'll have

00:09:07.220 --> 00:09:11.315
this intersection operator that will take an arbitrary set of boxes,

00:09:11.315 --> 00:09:13.095
and produce a new box.

00:09:13.095 --> 00:09:19.264
Now the way we define this operator is we need to say what is happening to the center,

00:09:19.264 --> 00:09:22.780
and what is happening to the offset of the intersection.

00:09:22.780 --> 00:09:27.255
The way we are going to find the center of the intersection is,

00:09:27.255 --> 00:09:30.875
we are going to do this through a learned oper- operation.

00:09:30.875 --> 00:09:32.855
Our learning operation will take the following,

00:09:32.855 --> 00:09:36.630
it will take the centers of the boxes that are on

00:09:36.630 --> 00:09:41.115
the input and then we are going to learn this function, f,

00:09:41.115 --> 00:09:44.825
that takes a center of the box and, um,

00:09:44.825 --> 00:09:52.245
and transforms it and then we will apply softmax to this, uh, to dysfunctions.

00:09:52.245 --> 00:09:55.395
What this will allow us to do is that,

00:09:55.395 --> 00:09:59.735
basically the - the intuition is that the center of the intersection would be

00:09:59.735 --> 00:10:04.805
somewhere in this green region defined by the centers of the input boxes.

00:10:04.805 --> 00:10:09.400
We define the center as a weighted sum of the input box centers,

00:10:09.400 --> 00:10:12.230
where W is this weight,

00:10:12.230 --> 00:10:18.165
the importance of our- of our given box on the intersection of boxes.

00:10:18.165 --> 00:10:20.295
So, W represents, in some sense,

00:10:20.295 --> 00:10:24.060
a self attention score on the cen- how much a center of

00:10:24.060 --> 00:10:28.360
each input box affects the center of the intersection box.

00:10:28.360 --> 00:10:32.730
Uh, and this funny operator is called Hadamard product,

00:10:32.730 --> 00:10:34.865
which is basically element-wise product, right?

00:10:34.865 --> 00:10:36.620
It's just you - you uh - uh,

00:10:36.620 --> 00:10:38.955
take product of cells uh,

00:10:38.955 --> 00:10:41.610
that correspond, uh, to each other.

00:10:41.610 --> 00:10:45.170
So this is how center uh,

00:10:45.170 --> 00:10:46.640
is defined and of course,

00:10:46.640 --> 00:10:50.025
f is a function that we are going to learn.

00:10:50.025 --> 00:10:53.790
Similarly now, we also have to define the offset.

00:10:53.790 --> 00:10:57.180
And the way we are going to define the offset of the intersection is to

00:10:57.180 --> 00:11:00.900
take- is we'll take the min- smallest of all the input boxes,

00:11:00.900 --> 00:11:04.080
so we take the minimum in terms of the offsets.

00:11:04.080 --> 00:11:08.385
And then we are going to also learn this offset function,

00:11:08.385 --> 00:11:13.005
f offset, that is going to aggregate and transform the offsets.

00:11:13.005 --> 00:11:15.850
So here, the - the intuition is that if we first take

00:11:15.850 --> 00:11:20.160
the minimum of the offsets of input boxes and then make the model more

00:11:20.160 --> 00:11:25.830
expressive by introducing- introducing this new function f_off for extracting

00:11:25.830 --> 00:11:32.265
the representation of the input boxes with the sigmoid function to guarantee shrinking,

00:11:32.265 --> 00:11:34.470
uh, of the- of the offset.

00:11:34.470 --> 00:11:38.205
Again this f_off will have some trainable parameters uh,

00:11:38.205 --> 00:11:40.350
that will uh, that we are going to learn

00:11:40.350 --> 00:11:43.840
through the training process uh, of the entire model.

00:11:43.840 --> 00:11:46.480
So, uh, you know, intuitively,

00:11:46.480 --> 00:11:49.455
the idea is that once I have two boxes on the input,

00:11:49.455 --> 00:11:54.530
I wanna- I wanna produce the intersection of the two boxes and in our case,

00:11:54.530 --> 00:11:56.615
the intersection of the two boxes, for example,

00:11:56.615 --> 00:11:59.580
would be this, uh, shaded, uh, area here.

00:11:59.580 --> 00:12:04.685
Uh, and that- and whatever entities are enclosed or are close to this box,

00:12:04.685 --> 00:12:05.920
uh, those are the answers,

00:12:05.920 --> 00:12:08.580
uh, to our, uh, query.

00:12:08.580 --> 00:12:11.415
So now, what we need to do is,

00:12:11.415 --> 00:12:13.605
so far I said, oh, um,

00:12:13.605 --> 00:12:17.205
entities that are the answer that are included in the box,

00:12:17.205 --> 00:12:19.775
they have to be kind of inside the box, right?

00:12:19.775 --> 00:12:22.930
In reality, this might be uh, harder,

00:12:22.930 --> 00:12:26.190
because, uh, data is noisy, um, uh,

00:12:26.190 --> 00:12:28.050
there might be inconsistencies,

00:12:28.050 --> 00:12:29.785
contradictions in the knowledge graph,

00:12:29.785 --> 00:12:35.025
so we need to define the notion of distance between the box and a point.

00:12:35.025 --> 00:12:39.645
And the idea will be that, uh, we are going to define this distance to have two parts.

00:12:39.645 --> 00:12:43.470
We're going to define the distance from the center to the point,

00:12:43.470 --> 00:12:45.835
if the point is inside the box,

00:12:45.835 --> 00:12:47.220
and if it's outside the box,

00:12:47.220 --> 00:12:51.389
then we'll take the distance between the center and the corner and the corner,

00:12:51.389 --> 00:12:52.830
uh, and the point.

00:12:52.830 --> 00:12:57.490
Um, and the point here is that we wanna be able to uh,

00:12:57.490 --> 00:13:00.030
account for the distance differently.

00:13:00.030 --> 00:13:03.095
We wanna measure distance, uh, uh,

00:13:03.095 --> 00:13:05.140
from the center if, uh,

00:13:05.140 --> 00:13:09.300
when the- when the point is inside the box in some set of units.

00:13:09.300 --> 00:13:11.415
And then we are going to have this, uh,

00:13:11.415 --> 00:13:14.460
weight scalar Alpha that will, uh, uh,

00:13:14.460 --> 00:13:17.790
be less than one so that basically we- we are going to

00:13:17.790 --> 00:13:21.755
penalize the- the- the distance from the center of the box,

00:13:21.755 --> 00:13:23.805
uh, more if the point is, uh,

00:13:23.805 --> 00:13:25.605
inside than if it is,

00:13:25.605 --> 00:13:26.885
uh, outside the box.

00:13:26.885 --> 00:13:30.465
Uh, and the intuition is that if the point is enclosing the box,

00:13:30.465 --> 00:13:32.775
it should- the box should be, uh,

00:13:32.775 --> 00:13:34.185
it should be very close, uh,

00:13:34.185 --> 00:13:39.945
to the center of the box so that we get more robustness from our- from our approach.

00:13:39.945 --> 00:13:44.700
We don't want the point to be kind of close to the border or the edge of the box,

00:13:44.700 --> 00:13:48.570
we want it towards the center of the box.

00:13:48.570 --> 00:13:53.765
So that's how we now define the- the distance between the entity and the box.

00:13:53.765 --> 00:13:56.765
So now when we have the final embedding of the query,

00:13:56.765 --> 00:14:00.020
all we do is basically apply this distance, um,

00:14:00.020 --> 00:14:04.020
and say who are the points that are closest according to this distance,

00:14:04.020 --> 00:14:05.345
uh, to the center,

00:14:05.345 --> 00:14:07.245
uh, of the box.

00:14:07.245 --> 00:14:11.235
So now we have discussed two things.

00:14:11.235 --> 00:14:13.995
We discussed how we can embed everything, uh,

00:14:13.995 --> 00:14:15.630
all the entities as boxes,

00:14:15.630 --> 00:14:19.470
how we learn the- the box transformation operation,

00:14:19.470 --> 00:14:23.565
the projection operation that is one per relation,

00:14:23.565 --> 00:14:25.355
and then we talked about how we learn

00:14:25.355 --> 00:14:31.905
these intersection conjunction operator that takes the- as an input,

00:14:31.905 --> 00:14:32.985
a set of boxes,

00:14:32.985 --> 00:14:35.685
and produces the intersection box.

00:14:35.685 --> 00:14:39.065
Of course, our natural question next is,

00:14:39.065 --> 00:14:43.050
could I- could I have these predictive queries,

00:14:43.050 --> 00:14:45.575
uh, even with a union operator?

00:14:45.575 --> 00:14:49.215
So, for example, to be able to answer queries like OR.

00:14:49.215 --> 00:14:52.485
Um, and so next what we are going to look at is,

00:14:52.485 --> 00:14:56.295
how would you be able to answer what we will call AND-OR queries?

00:14:56.295 --> 00:15:01.890
Or what is technically called existential positive first-order queries.

00:15:01.890 --> 00:15:06.795
So basically, these are queries with conjunction and disjunction operator, right?

00:15:06.795 --> 00:15:10.325
So the question is, how would we be able to dis- are we able to

00:15:10.325 --> 00:15:13.800
design a disjunction operator and embed

00:15:13.800 --> 00:15:17.700
AND-OR queries in low dimensional vector space and be able to

00:15:17.700 --> 00:15:21.965
answer predictive AND-OR queries in the,

00:15:21.965 --> 00:15:23.805
uh, space as well.

00:15:23.805 --> 00:15:26.070
So the question is,

00:15:26.070 --> 00:15:30.590
can we embed AND- AND-OR queries in a low-dimensional space?

00:15:30.590 --> 00:15:32.775
The answer is actually no.

00:15:32.775 --> 00:15:36.485
The reason for that is that allowing union over

00:15:36.485 --> 00:15:40.890
arbitrary sets requires high dimensional embeddings.

00:15:40.890 --> 00:15:45.440
So let me quickly give you a sense why we need a lot of dimensions.

00:15:45.440 --> 00:15:48.390
Imagine I'm given three queries, q1, q2,

00:15:48.390 --> 00:15:51.915
q3, and each one of them has one answer.

00:15:51.915 --> 00:15:54.280
Uh, you know, q1 has v1 as an entity,

00:15:54.280 --> 00:15:55.865
v1 has answer q2,

00:15:55.865 --> 00:15:58.155
v2, and q3,

00:15:58.155 --> 00:16:00.045
v3 entity has the answer.

00:16:00.045 --> 00:16:03.740
So now, imagine I- I allow an entity operation, right,

00:16:03.740 --> 00:16:06.010
which basically means I can take, uh,

00:16:06.010 --> 00:16:08.940
any pair of queries and do an OR between them.

00:16:08.940 --> 00:16:11.145
So the answer set will be, uh,

00:16:11.145 --> 00:16:14.640
the answer set for the first query union the answer set,

00:16:14.640 --> 00:16:16.455
uh, of the second query.

00:16:16.455 --> 00:16:19.335
So given that we have two queries,

00:16:19.335 --> 00:16:22.530
sorry, given that we have three queries, the question is,

00:16:22.530 --> 00:16:26.770
uh, can- would we be able to model union operation when we embed them,

00:16:26.770 --> 00:16:29.055
let's say on a two-dimensional plane?

00:16:29.055 --> 00:16:30.880
And yes, you could, right?

00:16:30.880 --> 00:16:33.720
Basically, you say for every individual query,

00:16:33.720 --> 00:16:38.140
I can simply put a box around the entity and this would mean, uh,

00:16:38.140 --> 00:16:39.305
for a given query,

00:16:39.305 --> 00:16:44.085
I want the entity that is the answer to it to be inside the box and that's,

00:16:44.085 --> 00:16:45.930
uh, you know, easy to achieve.

00:16:45.930 --> 00:16:50.715
We can space these entities apart and put a box around each one of them and say,

00:16:50.715 --> 00:16:53.430
uh-huh, the box is the embedding of the query and

00:16:53.430 --> 00:16:56.420
the answer to the query is embedded inside the box.

00:16:56.420 --> 00:16:57.935
You know, all good.

00:16:57.935 --> 00:17:00.645
How about the unions?

00:17:00.645 --> 00:17:02.745
Um, in this case,

00:17:02.745 --> 00:17:04.955
I can easily, uh, do the union.

00:17:04.955 --> 00:17:08.495
This is, for example, how a box of union 1,

00:17:08.495 --> 00:17:12.300
query 1, union query 2 would look like so, uh,

00:17:12.300 --> 00:17:15.065
q1 or q2, this is how, uh,

00:17:15.065 --> 00:17:17.570
q2 or q3 would look like,

00:17:17.570 --> 00:17:18.780
and this is how uh,

00:17:18.780 --> 00:17:21.580
q1, uh, or q3, uh, would look like.

00:17:21.580 --> 00:17:28.040
So it seems it all works for three queries in two dimensions. However-

00:17:28.040 --> 00:17:30.730
What if we have four points?

00:17:30.730 --> 00:17:32.620
So imagine now I have four queries.

00:17:32.620 --> 00:17:36.235
I have four queries each one with one entity as the answer.

00:17:36.235 --> 00:17:40.795
Can I now use a two-dimensional space to embed them,

00:17:40.795 --> 00:17:46.750
um, and be able to do arbitrary unions between arbitrary queries?

00:17:46.750 --> 00:17:51.940
Uh, and it turns out I cannot design a box embedding such that, for example,

00:17:51.940 --> 00:17:58.330
in this case, that would represent the union of q, q_2, or q_4.

00:17:58.330 --> 00:18:03.190
Because there will always be some other kind of box or some other entity,

00:18:03.190 --> 00:18:05.950
um, uh, in- in between them, right?

00:18:05.950 --> 00:18:08.740
And if I move this entity away, perhaps here,

00:18:08.740 --> 00:18:13.315
then I won't be able to- to- to model the union between v_1 and v_4.

00:18:13.315 --> 00:18:17.800
So basically, um, there will always be, um, some issue.

00:18:17.800 --> 00:18:21.220
And, uh, what is the conclusion, or if you,

00:18:21.220 --> 00:18:24.745
um, if you do the, uh, mathematics carefully,

00:18:24.745 --> 00:18:29.335
what turns out is that if you have M, uh,

00:18:29.335 --> 00:18:34.945
queries or M entities with non-overlapping answers um,

00:18:34.945 --> 00:18:40.945
then you need the dimensionality of order M to handle arbitrary OR queries, right?

00:18:40.945 --> 00:18:44.725
So in our case, we said if I have three queries, I need two-dimensions,

00:18:44.725 --> 00:18:47.905
if I have four queries I need three-dimensions,

00:18:47.905 --> 00:18:49.135
and so on and so forth.

00:18:49.135 --> 00:18:55.105
So because real- real world knowledge graph have a lot of entities, for example,

00:18:55.105 --> 00:19:01.420
you know, FB15k has 15,000 entities and it's considered a small knowledge graph.

00:19:01.420 --> 00:19:04.450
This would mean that if we want to be able to- to uh,

00:19:04.450 --> 00:19:10.750
model arbitrary OR operation between arbitrary sets of entities,

00:19:10.750 --> 00:19:13.960
this would mean we need an embedding dimension of 15,000.

00:19:13.960 --> 00:19:15.610
And uh, that's far uh,

00:19:15.610 --> 00:19:18.835
far too much for us to be able to do this.

00:19:18.835 --> 00:19:23.050
So, um, it seems, um, hopeless, right?

00:19:23.050 --> 00:19:28.570
Since we cannot embed AND-OR queries in low-dimensional space can we still handle them?

00:19:28.570 --> 00:19:30.970
And actually, the answer is yes.

00:19:30.970 --> 00:19:36.730
And the answer is yes because we can rewrite the query to, um, in uh,

00:19:36.730 --> 00:19:41.365
into a different form so that the query is kind of logically equivalent,

00:19:41.365 --> 00:19:45.720
but the union operation happens all at the end, right?

00:19:45.720 --> 00:19:49.080
So the idea is if I have the original query plan, where I,

00:19:49.080 --> 00:19:50.865
you know take two projections,

00:19:50.865 --> 00:19:53.549
take the union, take one more projection,

00:19:53.549 --> 00:19:55.530
and take- then take an intersection,

00:19:55.530 --> 00:20:01.645
I can rewrite this into a different query plan that gives me the identical answer,

00:20:01.645 --> 00:20:06.085
it's logically equivalent, but the union only happens at the end.

00:20:06.085 --> 00:20:08.560
So why is this beneficial?

00:20:08.560 --> 00:20:12.100
Because I already know how to answer this part to get a box.

00:20:12.100 --> 00:20:15.610
I know how to answer this- this part up to here to get a box.

00:20:15.610 --> 00:20:18.835
So now, uh, write these the answer to my query?

00:20:18.835 --> 00:20:23.860
Is simply entities included in the first box and entities included in the second box.

00:20:23.860 --> 00:20:28.045
So that's very easy to do because the union occurs,

00:20:28.045 --> 00:20:31.705
uh, at, uh, always as- as a last step.

00:20:31.705 --> 00:20:37.015
So what is important is any AND-OR query can be transformed into uh,

00:20:37.015 --> 00:20:39.520
an equivalent what is called, um,

00:20:39.520 --> 00:20:44.395
disjunctive normal form, which is a disjunction of conjunctive queries.

00:20:44.395 --> 00:20:50.875
Um, and this means that if I have a query that's now a disjunction of conjunctions,

00:20:50.875 --> 00:20:53.560
I can simply first answer these conjunctions,

00:20:53.560 --> 00:20:57.820
and then take the OR or the union at the end.

00:20:57.820 --> 00:20:59.770
So it means, um,

00:20:59.770 --> 00:21:04.195
we can aggregate these unions uh, at the last step.

00:21:04.195 --> 00:21:10.780
That is one caveat is that when you do this transformation into disjunctive normal form,

00:21:10.780 --> 00:21:14.125
so from the original query to the disjunctive normal form,

00:21:14.125 --> 00:21:17.305
the size of the query can increase exponentially.

00:21:17.305 --> 00:21:18.640
Um, but in our case,

00:21:18.640 --> 00:21:21.265
this is not the problem because answering queries um,

00:21:21.265 --> 00:21:23.530
is so uh, is so fast,

00:21:23.530 --> 00:21:24.985
it's just kind of uh,

00:21:24.985 --> 00:21:26.740
navigating the embedding space.

00:21:26.740 --> 00:21:29.950
So this doesn't, uh, doesn't sound like too big,

00:21:29.950 --> 00:21:31.900
uh, of a problem.

00:21:31.900 --> 00:21:35.140
So now that we have um,

00:21:35.140 --> 00:21:41.250
defined the uh, the disjunctive normal form and we have rewritten the uh,

00:21:41.250 --> 00:21:47.020
the query as a set of conjunctive queries and then apply the OR operation at the end,

00:21:47.020 --> 00:21:51.970
then all we need to do is to change the notion of the distance between the query,

00:21:51.970 --> 00:21:55.090
the embedding of the query um, and the entity.

00:21:55.090 --> 00:21:58.210
And the way we can write this out mathematically is very intuitive.

00:21:58.210 --> 00:22:01.750
We say that um, the query in the disjunctive normal forum,

00:22:01.750 --> 00:22:05.365
conjunctive query q_1 or q_2 or q_3,

00:22:05.365 --> 00:22:08.050
we can simply define the distance between the embedding of

00:22:08.050 --> 00:22:11.380
this query and the entity to be- to be the minimum of

00:22:11.380 --> 00:22:14.920
the distances between the- the box distances

00:22:14.920 --> 00:22:17.590
between the individual conjunctive queries and that entity.

00:22:17.590 --> 00:22:21.340
So basically we say the entity is an answer uh,

00:22:21.340 --> 00:22:24.790
to the query if it is inside at

00:22:24.790 --> 00:22:28.660
least one of the individual conjunctive query boxes, right?

00:22:28.660 --> 00:22:32.620
So that it is close to at least one of the,

00:22:32.620 --> 00:22:34.615
uh, conjunctive queries q.

00:22:34.615 --> 00:22:36.700
So that's why we have the minimum here, right?

00:22:36.700 --> 00:22:39.534
So as long as v is the answer to the one conjunction,

00:22:39.534 --> 00:22:45.050
query q then the distance between that query and v will be uh, very small.

00:22:45.050 --> 00:22:51.045
And we achieve this by using this minimum uh, based uh, distance.

00:22:51.045 --> 00:22:55.510
So, um, this now, uh, er, uh,

00:22:55.510 --> 00:22:58.180
allows us basically to- to answer uh,

00:22:58.180 --> 00:23:01.330
arbitrary AND-OR predictive queries.

00:23:01.330 --> 00:23:03.160
So the way we would go about this,

00:23:03.160 --> 00:23:07.705
if- as we are given a query q at the beginning,

00:23:07.705 --> 00:23:11.020
we would rewrite it into a disjunctive normal form.

00:23:11.020 --> 00:23:15.700
So a, uh, disjunction of conjunctive queries q_1 to q_m.

00:23:15.700 --> 00:23:21.610
We would uh, embed this q_1 to q_m using this set of box operations,

00:23:21.610 --> 00:23:25.000
meaning uh, projections and uh, intersections.

00:23:25.000 --> 00:23:29.530
And then we would simply calculate the box distance between each q_i uh,

00:23:29.530 --> 00:23:36.490
from the disjunctive normal form and entity v and uh, take the minimum of these distances.

00:23:36.490 --> 00:23:40.360
And then the final score of an entity is simply the dista- is

00:23:40.360 --> 00:23:44.390
this minimum base distance between the entire uh, query uh, and uh,

00:23:44.390 --> 00:23:47.860
the- and the embedding of a given entity uh,

00:23:47.860 --> 00:23:52.915
for which we are interested in assessing how likely is that the entity an answer uh,

00:23:52.915 --> 00:23:55.285
to our uh, to our query.

00:23:55.285 --> 00:23:59.560
So now we have talked about how the method

00:23:59.560 --> 00:24:04.090
works from the point of view of once the embeddings are there,

00:24:04.090 --> 00:24:06.970
once the box operators are there, uh,

00:24:06.970 --> 00:24:11.380
how do we apply it to answer an arbitrary predictive query?

00:24:11.380 --> 00:24:17.425
The question is, uh what kind of training procedure do we use to learn this all?

00:24:17.425 --> 00:24:18.880
What does this mean is,

00:24:18.880 --> 00:24:22.840
we need basically a simil- a- a setup similar to knowledge graph

00:24:22.840 --> 00:24:27.235
completion task so that we can learn all these parameters, right?

00:24:27.235 --> 00:24:28.839
Um, when I say parameters,

00:24:28.839 --> 00:24:31.030
I mean we need to learn entity embeddings,

00:24:31.030 --> 00:24:33.340
we need to learn these relation embeddings,

00:24:33.340 --> 00:24:39.205
these box transformations, and we need to learn the intersection operator.

00:24:39.205 --> 00:24:44.335
And the way we are going to learn this is basically that we are going to select uh,

00:24:44.335 --> 00:24:47.365
or sample or create a set of queries.

00:24:47.365 --> 00:24:50.920
For every query, we are going to have a positive set of entities.

00:24:50.920 --> 00:24:52.570
This will be our set of answers.

00:24:52.570 --> 00:24:54.910
We are going to have a negative set of entities,

00:24:54.910 --> 00:24:56.920
this will be non-answers.

00:24:56.920 --> 00:25:00.790
And, uh, our goal will be to- to learn all these uh,

00:25:00.790 --> 00:25:04.840
parameters in such a way that answers are included

00:25:04.840 --> 00:25:09.895
in the final box and non-answers are uh, outside the box.

00:25:09.895 --> 00:25:13.780
So let me, uh, uh, summarize this.

00:25:13.780 --> 00:25:18.010
So we are going to first randomly sample query q from

00:25:18.010 --> 00:25:20.065
the training knowledge graph and

00:25:20.065 --> 00:25:25.090
identify an- an entity v that is the answer uh, to that query.

00:25:25.090 --> 00:25:29.215
Then we are also going to identify some negative entity,

00:25:29.215 --> 00:25:30.550
let's call it v prime,

00:25:30.550 --> 00:25:33.160
that is not an answer to the query, right?

00:25:33.160 --> 00:25:34.450
So for example, I could say,

00:25:34.450 --> 00:25:36.655
uh, I start uh, with uh,

00:25:36.655 --> 00:25:37.990
let's go back to our uh,

00:25:37.990 --> 00:25:40.390
Barack Obama nationality American.

00:25:40.390 --> 00:25:45.565
So, uh, I would say- I would sample a query um, uh, nationality.

00:25:45.565 --> 00:25:48.310
This is a simple kind of knowledge graph completion query,

00:25:48.310 --> 00:25:50.185
not even a multi- multi-hop.

00:25:50.185 --> 00:25:51.910
Uh, I start with Obama,

00:25:51.910 --> 00:25:53.410
along with the nationality,

00:25:53.410 --> 00:25:55.885
I find American, so that's a positive entity.

00:25:55.885 --> 00:26:00.175
And then perhaps I say a negative entity could be some other random uh,

00:26:00.175 --> 00:26:02.695
entity in uh, in the graph.

00:26:02.695 --> 00:26:05.590
Um, perhaps it could be Paris, uh,

00:26:05.590 --> 00:26:08.320
or if I want to be smarter I say I have the true entities

00:26:08.320 --> 00:26:11.200
of type Americans, so United States.

00:26:11.200 --> 00:26:14.500
So I want to pick another country, perhaps Germany,

00:26:14.500 --> 00:26:15.940
as a negative example,

00:26:15.940 --> 00:26:18.850
as a non-answer uh, to this query.

00:26:18.850 --> 00:26:21.265
Now that um, I,

00:26:21.265 --> 00:26:25.164
now that I have sampled the query and the answer and non-answer,

00:26:25.164 --> 00:26:32.035
I embed the query using the transformations and then I calculate the score function f uh,

00:26:32.035 --> 00:26:35.125
of entity v, which is the answer entity,

00:26:35.125 --> 00:26:36.640
and the entity v prime,

00:26:36.640 --> 00:26:39.640
which is the non-answer uh, entity.

00:26:39.640 --> 00:26:43.960
And then the goal is that now I can compute the gradients, uh,

00:26:43.960 --> 00:26:46.165
with respect, uh, to this, uh,

00:26:46.165 --> 00:26:49.990
loss function l where the goal is to maximize,

00:26:49.990 --> 00:26:53.995
uh, the- the score of the entity v. So basically, uh,

00:26:53.995 --> 00:26:56.605
it means maximize the negative distance,

00:26:56.605 --> 00:26:58.420
which means minimize the distance,

00:26:58.420 --> 00:27:02.965
while minimizing, uh, the distance of the non-answer.

00:27:02.965 --> 00:27:06.100
So the lo- the way we write the loss is, we say, uh, s- uh, uh,

00:27:06.100 --> 00:27:09.820
f- uh, Sigma is a sigmoid function,

00:27:09.820 --> 00:27:11.425
uh, that has value,

00:27:11.425 --> 00:27:12.730
you know, between 0 and 1,

00:27:12.730 --> 00:27:14.635
so basically, I'm saying I want,

00:27:14.635 --> 00:27:17.140
uh, to, uh, maximize, uh,

00:27:17.140 --> 00:27:19.360
f for, uh, the answer,

00:27:19.360 --> 00:27:20.935
and I wanna minimize,

00:27:20.935 --> 00:27:23.020
uh, f for the non-answer.

00:27:23.020 --> 00:27:26.440
And now I can take gradient or derivative with

00:27:26.440 --> 00:27:30.280
respect to this loss function to then be able to update

00:27:30.280 --> 00:27:34.180
both the entity embeddings as well as the projection and

00:27:34.180 --> 00:27:39.985
intersection operator parameters in order to be able to learn this, uh, well.

00:27:39.985 --> 00:27:45.670
Of course, we are not only to  going to sample one-hop queries,

00:27:45.670 --> 00:27:47.950
we are also going to sample two-hop queries,

00:27:47.950 --> 00:27:51.130
three-hop queries, intersection type queries, uh,

00:27:51.130 --> 00:27:53.695
all kinds of different, uh, query structures,

00:27:53.695 --> 00:27:54.970
and that will be, uh,

00:27:54.970 --> 00:27:56.740
our, uh, training set.

00:27:56.740 --> 00:27:58.060
And then given these queries,

00:27:58.060 --> 00:27:59.200
given an answer entity,

00:27:59.200 --> 00:28:00.955
the- and non-answer entity,

00:28:00.955 --> 00:28:03.895
we are going to, uh, optimize this likelihood,

00:28:03.895 --> 00:28:07.090
meaning we are going to find parameters of the model

00:28:07.090 --> 00:28:10.285
which is embeddings of entities plus these,

00:28:10.285 --> 00:28:12.685
uh, operators so that all these, uh,

00:28:12.685 --> 00:28:16.210
will, uh, optimize, uh, the loss function.

00:28:16.210 --> 00:28:18.700
So how do we, uh,

00:28:18.700 --> 00:28:20.380
how do we instantiate, uh,

00:28:20.380 --> 00:28:22.285
a query, uh, in the knowledge graph?

00:28:22.285 --> 00:28:25.690
We will assume we are given a query template, and then we, uh,

00:28:25.690 --> 00:28:28.075
in- instantiate the query, uh,

00:28:28.075 --> 00:28:30.625
will simply be to do the backward walking.

00:28:30.625 --> 00:28:33.595
Uh, what I mean by that is we are, uh,

00:28:33.595 --> 00:28:36.790
basically start from the initial answer entity,

00:28:36.790 --> 00:28:41.740
and then we are kind of going to walk backwards towards the anchored entities, right?

00:28:41.740 --> 00:28:43.210
So, um, in our case,

00:28:43.210 --> 00:28:44.440
for example, we could say,

00:28:44.440 --> 00:28:48.100
let's take fulvestrant as our, uh, answer entity.

00:28:48.100 --> 00:28:50.740
So now we are going- now that we have kind of

00:28:50.740 --> 00:28:53.650
randomly picked this entity from the knowledge graph,

00:28:53.650 --> 00:28:56.440
we're going to kind of move backward, uh,

00:28:56.440 --> 00:28:59.890
along the knowledge graph to then get the- the query plan,

00:28:59.890 --> 00:29:00.940
the query structure, right?

00:29:00.940 --> 00:29:02.590
So we are just at fulvestrant,

00:29:02.590 --> 00:29:04.720
then we, um, uh, move,

00:29:04.720 --> 00:29:08.529
we say we're- we will need to take intersection of two relations,

00:29:08.529 --> 00:29:09.940
relation 1 and relation 2,

00:29:09.940 --> 00:29:12.100
so let's pick two relations from,

00:29:12.100 --> 00:29:14.770
uh, fulvestrant and move backward.

00:29:14.770 --> 00:29:17.020
And then now that we are here,

00:29:17.020 --> 00:29:19.330
we moved across TreatedBy.

00:29:19.330 --> 00:29:22.255
Uh, now, we can again move one step, uh,

00:29:22.255 --> 00:29:25.795
backward along the projection operator, um,

00:29:25.795 --> 00:29:29.530
for the second type of relation like, uh, associated.

00:29:29.530 --> 00:29:33.025
And, uh, now this will now become my anchor entity.

00:29:33.025 --> 00:29:36.985
And now, uh, I do the same thing for the second relation,

00:29:36.985 --> 00:29:40.930
uh, here CausedBy and find the second, uh, anchor entity.

00:29:40.930 --> 00:29:45.835
So now I have just sampled the query that goes from ESR2 and shortness of breath,

00:29:45.835 --> 00:29:51.715
through associated TreatedBy, as well as from shortness of breath to CausedBy,

00:29:51.715 --> 00:29:54.010
and the intersection of them is the fulvestrant.

00:29:54.010 --> 00:29:56.890
So this is now my sampling, uh, of the query.

00:29:56.890 --> 00:29:58.705
And then what I can do is, uh,

00:29:58.705 --> 00:30:03.625
find some entity that is not answer to this query and use that as a,

00:30:03.625 --> 00:30:06.625
uh, non, uh, answer, right?

00:30:06.625 --> 00:30:10.660
Uh, it is important when we do this sampling to be careful, uh,

00:30:10.660 --> 00:30:13.150
because the query q must have answers,

00:30:13.150 --> 00:30:14.950
uh, on the KG.

00:30:14.950 --> 00:30:19.630
Um, and we will take one of the answers as instantiated, uh,

00:30:19.630 --> 00:30:21.415
uh, answer for our, uh,

00:30:21.415 --> 00:30:24.760
positive example, and, um,

00:30:24.760 --> 00:30:28.390
we're then going to basically randomly sample some negative,

00:30:28.390 --> 00:30:32.740
uh, examples, non-answers, which are basically other entities, uh,

00:30:32.740 --> 00:30:36.685
in the knowledge graph, but we have to be careful that we are not, uh,

00:30:36.685 --> 00:30:39.955
by accident sampling some other entity that's also,

00:30:39.955 --> 00:30:42.400
uh, answer, uh, to the query.

00:30:42.400 --> 00:30:45.895
So that's, uh, essentially the idea.

00:30:45.895 --> 00:30:50.455
Um, and the- the- the impressive thing is that we can actually make this,

00:30:50.455 --> 00:30:54.385
uh, all work and that now we are able to answer arbitrary, uh,

00:30:54.385 --> 00:30:57.070
predictive queries in knowledge graphs, uh,

00:30:57.070 --> 00:30:59.785
even though they might be notoriously, uh,

00:30:59.785 --> 00:31:02.290
incomplete or, uh, may not have,

00:31:02.290 --> 00:31:03.895
uh, uh, all the edges.

00:31:03.895 --> 00:31:05.590
And what I wanna do to, uh,

00:31:05.590 --> 00:31:08.260
finish the lecture is give you a quick,

00:31:08.260 --> 00:31:10.970
um, example of how would this look like.

00:31:10.970 --> 00:31:15.930
So, for example, here we are going to take the Freebase 15,000, uh,

00:31:15.930 --> 00:31:18.790
knowledge graph, which is a knowledge graph about, uh,

00:31:18.790 --> 00:31:20.980
real-world entities, uh, people,

00:31:20.980 --> 00:31:22.255
uh, things like that.

00:31:22.255 --> 00:31:25.225
And imagine we wanna have a query, uh, you know,

00:31:25.225 --> 00:31:30.795
who are all male instrumentalists who play string instruments, right?

00:31:30.795 --> 00:31:32.205
Uh, and we are going to, uh,

00:31:32.205 --> 00:31:35.865
use our system to learn the embedding of, uh,

00:31:35.865 --> 00:31:40.184
all the nodes, uh, all the entities to learn the projection operator,

00:31:40.184 --> 00:31:42.215
to learn the conjunction operator.

00:31:42.215 --> 00:31:45.465
Um, and then we are going to take this, uh,

00:31:45.465 --> 00:31:48.765
high-dimensional embedding and we are going to project it

00:31:48.765 --> 00:31:52.765
down to just two dimensions so we can visualize it, right?

00:31:52.765 --> 00:31:55.300
So, um, here's the visualization, right?

00:31:55.300 --> 00:31:57.190
So here is at, uh,

00:31:57.190 --> 00:31:59.844
15,000, uh, different dots,

00:31:59.844 --> 00:32:03.700
one corresponding to the embedding of, uh, each entity,

00:32:03.700 --> 00:32:06.520
and these are real entities with real embeddings,

00:32:06.520 --> 00:32:08.890
and here is our, uh, query plan, right?

00:32:08.890 --> 00:32:10.690
We, uh, we wanna answer, uh,

00:32:10.690 --> 00:32:14.124
you know, who are male instrumentalists who play string instruments,

00:32:14.124 --> 00:32:18.820
so we'll start with string instruments as the anchor entity, go over, um,

00:32:18.820 --> 00:32:24.565
the instance of relation to find all st- instances of string instruments,

00:32:24.565 --> 00:32:26.140
then we are going to go over,

00:32:26.140 --> 00:32:29.575
uh, PlayedBy, uh, relation, uh,

00:32:29.575 --> 00:32:32.320
to identify all the- all the people who

00:32:32.320 --> 00:32:35.140
play these string instruments, any of them, right?

00:32:35.140 --> 00:32:38.245
And then we are going to go from node male to say

00:32:38.245 --> 00:32:41.995
instance of to find all the instances of male, uh,

00:32:41.995 --> 00:32:43.749
males in our dataset,

00:32:43.749 --> 00:32:46.990
and now we need to take the intersection to find all the males

00:32:46.990 --> 00:32:50.395
who are also playing any of the string, uh, instruments.

00:32:50.395 --> 00:32:52.660
So let me show you how this, uh,

00:32:52.660 --> 00:32:56.184
actually works in this, uh, two-dimensional projection.

00:32:56.184 --> 00:32:58.930
So, uh, the anchor node for string instrument,

00:32:58.930 --> 00:33:00.370
if you would, uh, locate it,

00:33:00.370 --> 00:33:02.665
is actually here, uh, the blue one.

00:33:02.665 --> 00:33:07.990
Now I will take and apply a box transformation that will say,

00:33:07.990 --> 00:33:13.120
uh, what are the instances of the string, uh, instrument, right?

00:33:13.120 --> 00:33:15.085
What are all the individual string instruments?

00:33:15.085 --> 00:33:17.245
Um, and if I do this,

00:33:17.245 --> 00:33:19.270
um, actually notice now,

00:33:19.270 --> 00:33:24.250
um, the- the dot- the- the dots will have different types of colors.

00:33:24.250 --> 00:33:28.480
True-positive means, this is a string instrument inside the box.

00:33:28.480 --> 00:33:32.860
Um, false-negative means this is a string instrument outside the box.

00:33:32.860 --> 00:33:35.860
Uh, false-positive would be, um,

00:33:35.860 --> 00:33:39.700
other entities that are not string instruments but are inside the box.

00:33:39.700 --> 00:33:44.125
And true-entities are non-string instruments outside the box.

00:33:44.125 --> 00:33:47.020
And what you see here is that basically,

00:33:47.020 --> 00:33:51.865
we are able to perfectly enclose all the string instruments inside the box,

00:33:51.865 --> 00:33:54.340
and there are 10- 10, uh,

00:33:54.340 --> 00:33:57.325
instances of a string instrument in our dataset.

00:33:57.325 --> 00:33:59.650
So we have just identified,

00:33:59.650 --> 00:34:03.055
uh, all the string instruments in the embedding space.

00:34:03.055 --> 00:34:06.910
Now we wanna take the box of, um,

00:34:06.910 --> 00:34:10.675
all the string instruments and transform it to cover,

00:34:10.675 --> 00:34:13.270
uh, the- the people,

00:34:13.270 --> 00:34:15.115
uh, females and males, right?

00:34:15.115 --> 00:34:16.945
Who play these instruments.

00:34:16.945 --> 00:34:19.660
Uh, and if we do this, uh, here is the,

00:34:19.660 --> 00:34:22.495
uh, these are the entities that are inside the box.

00:34:22.495 --> 00:34:25.630
Again, because this is a two-dimensional projection, you know,

00:34:25.630 --> 00:34:27.310
this is not a box,

00:34:27.310 --> 00:34:29.350
uh, but in high-dimensions it is.

00:34:29.350 --> 00:34:33.085
And again, we see that we are able to cover, basically, um,

00:34:33.085 --> 00:34:36.430
98, uh, percent of all the- all the,

00:34:36.430 --> 00:34:38.260
uh, all the- all the, uh,

00:34:38.260 --> 00:34:40.840
instrumentalists of string instruments,

00:34:40.840 --> 00:34:42.700
and that, we have a few false positives,

00:34:42.700 --> 00:34:45.775
basically a few other entities, um,

00:34:45.775 --> 00:34:48.610
that are not instrumentalists of string instruments,

00:34:48.610 --> 00:34:50.050
but are still inside the box, right?

00:34:50.050 --> 00:34:51.400
So there is a bit of error,

00:34:51.400 --> 00:34:55.240
but the point is now we have 472 instrumentalists,

00:34:55.240 --> 00:34:57.820
both musicians, female and male,

00:34:57.820 --> 00:35:00.580
who play string instruments like a guitar, right?

00:35:00.580 --> 00:35:02.215
So now, uh, with this,

00:35:02.215 --> 00:35:05.455
let's move to the second part where we take the male,

00:35:05.455 --> 00:35:06.850
uh, the node male.

00:35:06.850 --> 00:35:08.950
Um, the male- the node, uh,

00:35:08.950 --> 00:35:11.815
is here, uh, and now we wanna say, uh,

00:35:11.815 --> 00:35:14.080
do the box transformation instance of to

00:35:14.080 --> 00:35:17.455
cover all the males in this, uh, knowledge graph.

00:35:17.455 --> 00:35:22.855
And if we do this, this is kind of the entities that are inside the male box,

00:35:22.855 --> 00:35:25.750
it's, uh, 3,500 of them.

00:35:25.750 --> 00:35:30.775
So we basically went from one entity to a giant box that covers,

00:35:30.775 --> 00:35:34.015
uh, 3,500, uh, males that are,

00:35:34.015 --> 00:35:36.385
uh, represented in this dataset.

00:35:36.385 --> 00:35:38.755
Now that we have these two boxes,

00:35:38.755 --> 00:35:41.605
we wanna apply the intersection,

00:35:41.605 --> 00:35:43.540
uh, operator, uh, to this,

00:35:43.540 --> 00:35:46.765
that you take the two boxes and take the intersection between them.

00:35:46.765 --> 00:35:50.185
Um, and if you do this, the intersection, um,

00:35:50.185 --> 00:35:53.530
has, uh, almost 400 different entities,

00:35:53.530 --> 00:35:58.225
and these are the entities that are predicted to be,

00:35:58.225 --> 00:36:01.900
uh, male players of string, uh, instruments.

00:36:01.900 --> 00:36:04.720
What is interesting, you see that basically,

00:36:04.720 --> 00:36:07.420
we are able to almost perfectly answer, uh,

00:36:07.420 --> 00:36:11.065
this query even though we were doing all these operations,

00:36:11.065 --> 00:36:13.820
uh, directly, uh, in the embedding space.

00:36:13.820 --> 00:36:17.730
And this is just one example how we can basically answer, uh,

00:36:17.730 --> 00:36:19.860
arbitrary predictive queries, uh,

00:36:19.860 --> 00:36:24.485
over these, uh, types of incomplete, uh, knowledge graphs.

00:36:24.485 --> 00:36:28.255
So, um, to summarize today's lecture;

00:36:28.255 --> 00:36:29.740
uh, we introduced, uh,

00:36:29.740 --> 00:36:32.005
um, the problem of a, uh,

00:36:32.005 --> 00:36:36.850
logical reasoning in knowledge graphs using embeddings, and in particular,

00:36:36.850 --> 00:36:40.210
we talked about how are we formulating

00:36:40.210 --> 00:36:44.875
answering queries as a predictive machine learning task.

00:36:44.875 --> 00:36:48.745
So we basically, rather than traversing the knowledge graph,

00:36:48.745 --> 00:36:54.175
we have defined the task in terms of a binary prediction task that says,

00:36:54.175 --> 00:36:58.550
"Predict what entities are the answer to a given query."

00:36:58.550 --> 00:37:02.220
And the benefit of our approach is that it is,

00:37:02.220 --> 00:37:04.500
uh, very scalable, meaning, uh,

00:37:04.500 --> 00:37:07.935
answering queries is very simple because it just requires, uh,

00:37:07.935 --> 00:37:12.830
transforming boxes and then checking what entities are inside the box.

00:37:12.830 --> 00:37:16.060
Um, and it is also very robust because we

00:37:16.060 --> 00:37:19.285
don't rely on individual links of the knowledge graph,

00:37:19.285 --> 00:37:24.640
but we really rely on the embeddings and the relationships in the embedding space.

00:37:24.640 --> 00:37:29.170
Um, and the key idea for today's lecture was we wanna

00:37:29.170 --> 00:37:33.520
embed queries by navigating the embedding space, right?

00:37:33.520 --> 00:37:36.220
We have this com- we've- we took advantage of

00:37:36.220 --> 00:37:40.900
this compositional property of uh, TransE method,

00:37:40.900 --> 00:37:44.290
and then we extended TransE to this notion of

00:37:44.290 --> 00:37:49.660
box embeddings so that we can then define the intersection of boxes.

00:37:49.660 --> 00:37:55.420
Um, and we learned how to transform boxes according to given relations,

00:37:55.420 --> 00:37:57.445
we call this a projection operator,

00:37:57.445 --> 00:38:00.595
um, and then we also showed how the,

00:38:00.595 --> 00:38:04.870
um, how the union operations can also be carried

00:38:04.870 --> 00:38:10.450
out- carried out by rewriting the query into the- a disjunctive normal form and,

00:38:10.450 --> 00:38:12.595
um, apply the union operator,

00:38:12.595 --> 00:38:15.680
uh, all the way, uh, at the end.

